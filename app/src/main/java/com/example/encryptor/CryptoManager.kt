package com.example.encryptor

import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Log
import java.io.EOFException
import java.io.InputStream
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.CipherInputStream
import javax.crypto.CipherOutputStream
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec

data class EncryptionHeader(
    val contentCipherIv: ByteArray,
    val keyCipherIv: ByteArray,
    val passwordSalt: ByteArray,
    val encryptedStreamSecretKey: ByteArray
) // The rest is autogenerated by the IDE to allow valid comparisons.
{
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as EncryptionHeader

        if (!contentCipherIv.contentEquals(other.contentCipherIv)) return false
        if (!keyCipherIv.contentEquals(other.keyCipherIv)) return false
        if (!passwordSalt.contentEquals(other.passwordSalt)) return false
        if (!encryptedStreamSecretKey.contentEquals(other.encryptedStreamSecretKey)) return false

        return true
    }

    override fun hashCode(): Int {
        var result = contentCipherIv.contentHashCode()
        result = 31 * result + keyCipherIv.contentHashCode()
        result = 31 * result + passwordSalt.contentHashCode()
        result = 31 * result + encryptedStreamSecretKey.contentHashCode()
        return result
    }
}


class CryptoManager {
    // Static properties, pertain to the class rather than its instances.
    companion object {
        private const val KEY_SIZE = 256
        private const val ALGORITHM = KeyProperties.KEY_ALGORITHM_AES
        private const val BLOCK_MODE = KeyProperties.BLOCK_MODE_GCM
        private const val PADDING = KeyProperties.ENCRYPTION_PADDING_NONE
        private const val TRANSFORMATION = "$ALGORITHM/$BLOCK_MODE/$PADDING"
    }

    private val keyStore = KeyStore.getInstance("AndroidKeyStore").apply {
        load(null)
    }

    private fun initCipher(mode: String, secretKey: SecretKey, iv: ByteArray? = null): Cipher {
        val cipherInstance = Cipher.getInstance(TRANSFORMATION)

        return if (mode == "ENCRYPT") {
            cipherInstance.apply{ init(Cipher.ENCRYPT_MODE, secretKey) }
        } else if (mode == "DECRYPT" && iv != null) {
            cipherInstance.apply{ init(Cipher.DECRYPT_MODE, secretKey, GCMParameterSpec(128, iv)) }
        } else {
            throw Exception("C'mon, just choose the right mode and iv if necessary")
        }
    }

    //TODO: Implement both software and keystore generated keys according to the diagram.
    private fun retrieveOrCreateKey(keyAlias: String): SecretKey {
        try {
            val entry = keyStore.getEntry(keyAlias, null) as? KeyStore.SecretKeyEntry

            return if (entry != null) {
                entry.secretKey
            } else {
                generateHardwareBackedKey(keyAlias)
            }

        } catch (e: KeyStoreException) {
            // If the key is invalid (e.g., locked due to authentication), delete it.
            keyStore.deleteEntry(keyAlias)
            return generateHardwareBackedKey(keyAlias)
        } catch (e: Exception) {
            throw ErrorRetrievingKeyException("Error retrieving key: \"$keyAlias\"", e)
        }
    }


    private fun generateSoftwareKey(): SecretKey {
        val keyGenerator = KeyGenerator.getInstance(ALGORITHM)
        keyGenerator.init(KEY_SIZE)
        return keyGenerator.generateKey()
    }


    private fun generateHardwareBackedKey(keyAlias: String): SecretKey {
        val keyGenerator = KeyGenerator.getInstance(ALGORITHM, "AndroidKeyStore")

        keyGenerator.init(
            KeyGenParameterSpec.Builder(
                keyAlias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
            )
                .setBlockModes(BLOCK_MODE)
                .setEncryptionPaddings(PADDING)
                .setUserAuthenticationRequired(false)  // TODO: Set to true.
                .build()
        )

        return keyGenerator.generateKey()
    }


    private fun readFully(input: InputStream, buffer: ByteArray) {
        var bytesRead = 0
        while (bytesRead < buffer.size) {
            val read = input.read(buffer, bytesRead, buffer.size - bytesRead)
            if (read == -1) {
                throw EOFException("Unexpected end of stream while reading header data.")
            }
            bytesRead += read
        }
    }


    private fun extractDataFromHeader(input: InputStream): EncryptionHeader {
        val contentCipherIvSize = readTwoBytesToInt(input)
        val keyCipherIvSize = readTwoBytesToInt(input)
        val passwordSaltSize = readTwoBytesToInt(input)
        val encryptedStreamSecretKeySize = readTwoBytesToInt(input)

        val contentCipherIv = ByteArray(contentCipherIvSize)
        val keyCipherIv = ByteArray(keyCipherIvSize)
        val passwordSalt = ByteArray(passwordSaltSize)
        val encryptedStreamSecretKey = ByteArray(encryptedStreamSecretKeySize)

        readFully(input, contentCipherIv)
        readFully(input, keyCipherIv)
        readFully(input, passwordSalt)
        readFully(input, encryptedStreamSecretKey)

        return EncryptionHeader(
            contentCipherIv = contentCipherIv,
            keyCipherIv = keyCipherIv,
            passwordSalt = passwordSalt,
            encryptedStreamSecretKey = encryptedStreamSecretKey
        )
    }


    private fun deriveKeyFromPassword(
        password: String,
        salt: ByteArray,
        iterations: Int = 100_000,
        keySize: Int = KEY_SIZE
    ): SecretKeySpec {
        val keySpec = PBEKeySpec(password.toCharArray(), salt, iterations, keySize)
        val secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
        val secretKey = secretKeyFactory.generateSecret(keySpec)
        return SecretKeySpec(secretKey.encoded, ALGORITHM)
    }


    private fun generateRandomSalt(size: Int = 16): ByteArray {
        val salt = ByteArray(size)
        SecureRandom().nextBytes(salt)
        return salt
    }


    private fun readTwoBytesToInt(input: InputStream): Int {
        val leftByte = input.read()
        val rightByte = input.read()

        if (leftByte == -1 || rightByte == -1) {
            throw EOFException("Unexpected end of stream while reading 2-byte integer")
        }

        return (leftByte shl 8) or rightByte
    }

    fun encryptStream(
        fileIOStreams: IOStreams,
        metadataIOStreams: IOStreams,
        password: String,
    ): Boolean {
        return try {
            val unencryptedInputStream = fileIOStreams.input
            val encryptedOutputStream = fileIOStreams.output

            val masterKey = generateSoftwareKey()
            val contentCipher = initCipher("ENCRYPT", masterKey)

            if (password == "") {
                throw EmptyPasswordException("The password cannot be empty.")
            }

            val passwordSalt = generateRandomSalt()
            val secretKeyForMasterKey = deriveKeyFromPassword(password, passwordSalt)
            val keyCipher = initCipher("ENCRYPT", secretKeyForMasterKey)

            val intToTwoBytes: (Int) -> ByteArray = { num ->
                byteArrayOf(
                    ((num shr 8) and 0xFF).toByte(),   // Leftmost byte first.
                    (num and 0xFF).toByte()            // Rightmost byte second.
                )
            }

            val streamSecretKeyBytes = masterKey.encoded
                ?: throw IllegalStateException("Idk, the key should've been set by now.")

            val encryptedStreamSecretKey = keyCipher.doFinal(streamSecretKeyBytes)

            // TODO: Create, encrypt, and store a hardware-backed key in the metadata file for biometrics.
            // Read METADATA file if it exists
            // See if it contains a valid key alias
            // If it does, read it from the keystore
            // Otherwise create a new one

            // Create a header.
            // Sizes.
            encryptedOutputStream.write(intToTwoBytes(contentCipher.iv.size))
            encryptedOutputStream.write(intToTwoBytes(keyCipher.iv.size))
            encryptedOutputStream.write(intToTwoBytes(passwordSalt.size))
            encryptedOutputStream.write(intToTwoBytes(encryptedStreamSecretKey.size))
            // Header contents.
            encryptedOutputStream.write(contentCipher.iv)
            encryptedOutputStream.write(keyCipher.iv)
            encryptedOutputStream.write(passwordSalt)
            encryptedOutputStream.write(encryptedStreamSecretKey)

            // Encrypt main content.
            CipherInputStream(unencryptedInputStream, contentCipher).use { encryptedInputStream ->
                encryptedInputStream.copyTo(encryptedOutputStream)
                encryptedOutputStream.flush()
            }

            true
        } catch (e: EmptyPasswordException) {
            Log.e("EmptyPasswordException", "Empty password supplied.", e)
            false
        } catch (e: Exception) {
            Log.e("EncryptionError", "Encryption failed.", e)
            false
        }
    }


    fun decryptStream(
        fileIOStreams: IOStreams,
        password: String,
        isIntegrityCheck: Boolean = false,
    ): Boolean {
        return try {
            val encryptedInputStream = fileIOStreams.input
            val decryptedOutputStream = fileIOStreams.output

            val encryptionHeader = extractDataFromHeader(encryptedInputStream)
            val secretKeyForMasterKey = deriveKeyFromPassword(password, encryptionHeader.passwordSalt)
            val keyCipher = initCipher("DECRYPT", secretKeyForMasterKey, encryptionHeader.keyCipherIv)
            val masterKeyBytes = keyCipher.doFinal(encryptionHeader.encryptedStreamSecretKey)
            val masterKey = SecretKeySpec(masterKeyBytes, ALGORITHM)

            val streamCipher = initCipher("DECRYPT", masterKey, encryptionHeader.contentCipherIv)

            CipherInputStream(encryptedInputStream, streamCipher).use { decryptedInputStream ->
                if (!isIntegrityCheck) {
                    decryptedInputStream.copyTo(decryptedOutputStream)
                } else {
                    // Reduces the number of IO calls, making it faster.
                    val buffer = ByteArray(4096)
                    while (decryptedInputStream.read(buffer) != -1) {
                        // Just read through the file to force decryption/authentication.
                    }
                }
            }

            true
        } catch(e: Exception) {
            if (!isIntegrityCheck) {
                Log.e("DecryptionError", "Decryption failed!!!", e)
            } else {
                Log.e("IntegrityCheck", "Unexpected failure during integrity verification.", e)
            }

            false
        }
    }
}

class ErrorRetrievingKeyException(message: String, cause: Throwable? = null) : Exception(message, cause)
class EmptyPasswordException(message: String, cause: Throwable? = null) : Exception(message, cause)
