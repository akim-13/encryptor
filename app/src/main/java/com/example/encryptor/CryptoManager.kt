package com.example.encryptor

import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Log
import java.io.EOFException
import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.CipherInputStream
import javax.crypto.CipherOutputStream
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec

data class EncryptionHeader(
    val contentCipherIv: ByteArray,
    val keyCipherIv: ByteArray,
    val passwordSalt: ByteArray,
    val encryptedStreamSecretKey: ByteArray
) // The rest is autogenerated by the IDE to allow valid comparisons.
{
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as EncryptionHeader

        if (!contentCipherIv.contentEquals(other.contentCipherIv)) return false
        if (!keyCipherIv.contentEquals(other.keyCipherIv)) return false
        if (!passwordSalt.contentEquals(other.passwordSalt)) return false
        if (!encryptedStreamSecretKey.contentEquals(other.encryptedStreamSecretKey)) return false

        return true
    }

    override fun hashCode(): Int {
        var result = contentCipherIv.contentHashCode()
        result = 31 * result + keyCipherIv.contentHashCode()
        result = 31 * result + passwordSalt.contentHashCode()
        result = 31 * result + encryptedStreamSecretKey.contentHashCode()
        return result
    }
}


class CryptoManager {
    // Static properties, pertain to the class rather than its instances.
    companion object {
        private const val ALGORITHM = KeyProperties.KEY_ALGORITHM_AES
        private const val BLOCK_MODE = KeyProperties.BLOCK_MODE_GCM
        private const val PADDING = KeyProperties.ENCRYPTION_PADDING_NONE
        private const val TRANSFORMATION = "$ALGORITHM/$BLOCK_MODE/$PADDING"
    }

    private val keyStore = KeyStore.getInstance("AndroidKeyStore").apply {
        load(null)
    }

    private fun initCipher(mode: String, secretKey: SecretKey, iv: ByteArray? = null): Cipher {
        val cipherInstance = Cipher.getInstance(TRANSFORMATION)

        return if (mode == "ENCRYPT") {
            cipherInstance.apply{ init(Cipher.ENCRYPT_MODE, secretKey) }
        } else if (mode == "DECRYPT" && iv != null) {
            cipherInstance.apply{ init(Cipher.DECRYPT_MODE, secretKey, GCMParameterSpec(128, iv)) }
        } else {
            throw Exception("C'mon, just choose the right mode and iv if necessary")
        }
    }

    //FIXME: TODO: Implement both software and keystore generated keys according to the diagram.
    private fun retrieveOrCreateKey(keyAlias: String): SecretKey {
        try {
            val entry = keyStore.getEntry(keyAlias, null) as? KeyStore.SecretKeyEntry

            return if (entry != null) {
                entry.secretKey
            } else {
                createKey(keyAlias)
            }

        } catch (e: KeyStoreException) {
            // If the key is invalid (e.g., locked due to authentication), delete it.
            keyStore.deleteEntry(keyAlias)
            return createKey(keyAlias)
        } catch (e: Exception) {
            throw ErrorRetrievingKeyException("Error retrieving key: \"$keyAlias\"", e)
        }
    }


    private fun createKey(keyAlias: String): SecretKey {
        val keyGenerator = KeyGenerator.getInstance("AES")
        keyGenerator.init(256)
        return keyGenerator.generateKey()
    }


    /*private fun createKey(keyAlias: String): SecretKey {
        val keyGenerator = KeyGenerator.getInstance(ALGORITHM, "AndroidKeyStore")

        keyGenerator.init(
            KeyGenParameterSpec.Builder(
                keyAlias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
            )
                .setBlockModes(BLOCK_MODE)
                .setEncryptionPaddings(PADDING)
                .setUserAuthenticationRequired(false) // WARN: Must be false. Making it true makes the key hardware-backed and non-exportable,
                // meaning you can't get the key to encrypt it and store in the header.
                .build()
        )

        return keyGenerator.generateKey()
    }*/


    /*private fun readFully(input: InputStream, buffer: ByteArray) {
        var bytesRead = 0
        while (bytesRead < buffer.size) {
            val read = input.read(buffer, bytesRead, buffer.size - bytesRead)
            if (read == -1) {
                throw EOFException("Unexpected end of stream while reading header data.")
            }
            bytesRead += read
        }
    } */

    private fun readFully(input: InputStream, buffer: ByteArray, label: String) {
        var bytesRead = 0
        while (bytesRead < buffer.size) {
            val read = input.read(buffer, bytesRead, buffer.size - bytesRead)
            if (read == -1) {
                throw EOFException("Unexpected end of stream while reading $label")
            }
            bytesRead += read
        }
        println("$label (${buffer.size} bytes): ${buffer.joinToString(", ") { it.toUByte().toString() }}")
    }


    private fun extractDataFromHeader(input: InputStream): EncryptionHeader {
        val contentCipherIvSize = readTwoBytesToInt(input)
        val keyCipherIvSize = readTwoBytesToInt(input)
        val passwordSaltSize = readTwoBytesToInt(input)
        val encryptedStreamSecretKeySize = readTwoBytesToInt(input)

        val contentCipherIv = ByteArray(contentCipherIvSize)
        val keyCipherIv = ByteArray(keyCipherIvSize)
        val passwordSalt = ByteArray(passwordSaltSize)
        val encryptedStreamSecretKey = ByteArray(encryptedStreamSecretKeySize)

        /*readFully(input, contentCipherIv)
        readFully(input, keyCipherIv)
        readFully(input, passwordSalt)
        readFully(input, encryptedStreamSecretKey)*/

        readFully(input, contentCipherIv, "contentCipherIv")
        readFully(input, keyCipherIv, "keyCipherIv")
        readFully(input, passwordSalt, "passwordSalt")
        readFully(input, encryptedStreamSecretKey, "encryptedStreamSecretKey")

        return EncryptionHeader(
            contentCipherIv = contentCipherIv,
            keyCipherIv = keyCipherIv,
            passwordSalt = passwordSalt,
            encryptedStreamSecretKey = encryptedStreamSecretKey
        )
    }

    fun extractIvFromInputStream(inputStream: InputStream): ByteArray {
        val ivSize = readTwoBytesToInt(inputStream)
        val iv = ByteArray(ivSize)
        var totalRead = 0

        while (totalRead < ivSize) {
            val bytesRead = inputStream.read(iv, totalRead, ivSize - totalRead)
            if (bytesRead == -1) throw IOException("Unexpected EOF while reading IV")
            totalRead += bytesRead
        }

        return iv
    }

    fun deriveKeyFromPassword(
        password: String,
        salt: ByteArray,
        iterations: Int = 100_000,
        keyLength: Int = 256
    ): SecretKeySpec {
        val keySpec = PBEKeySpec(password.toCharArray(), salt, iterations, keyLength)
        val secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
        val secretKey = secretKeyFactory.generateSecret(keySpec)
        return SecretKeySpec(secretKey.encoded, "AES")
    }

    private fun generateRandomSalt(size: Int = 16): ByteArray {
        val salt = ByteArray(size)
        SecureRandom().nextBytes(salt)
        return salt
    }

    private fun readTwoBytesToInt(input: InputStream): Int {
        val leftByte = input.read()
        val rightByte = input.read()

        if (leftByte == -1 || rightByte == -1) {
            throw EOFException("Unexpected end of stream while reading 2-byte integer")
        }

        return (leftByte shl 8) or rightByte
    }


    fun encryptStream(
        unencryptedInputStream: InputStream,
        password: String,
        keyAlias: String,
        unencryptedOutputStream: OutputStream
    ): Boolean {
        return try {
            val streamSecretKey = retrieveOrCreateKey(keyAlias)
            val contentCipher = initCipher("ENCRYPT", streamSecretKey)

            if (password == "") throw EmptyPasswordException("The password cannot be empty.")

            val passwordSalt = generateRandomSalt()
            val secretKeyForSecretKey = deriveKeyFromPassword(password, passwordSalt)
            val keyCipher = initCipher("ENCRYPT", secretKeyForSecretKey)

            val intToTwoBytes: (Int) -> ByteArray = { num ->
                byteArrayOf(
                    ((num shr 8) and 0xFF).toByte(),   // Leftmost byte first.
                    (num and 0xFF).toByte()            // Rightmost byte second.
                )
            }

            val streamSecretKeyBytes = streamSecretKey.encoded
                ?: throw IllegalStateException("streamSecretKey encoding unavailable. " +
                        "Check if the key is exportable (has to be NOT backed by hardware)")

            val encryptedStreamSecretKey = keyCipher.doFinal(streamSecretKeyBytes)

            /* // Create a header.
            // Sizes.
            unencryptedOutputStream.write(intToTwoBytes(contentCipher.iv.size))
            unencryptedOutputStream.write(intToTwoBytes(keyCipher.iv.size))
            unencryptedOutputStream.write(intToTwoBytes(passwordSalt.size))
            unencryptedOutputStream.write(intToTwoBytes(encryptedStreamSecretKey.size))
            // Header contents.
            unencryptedOutputStream.write(contentCipher.iv)
            unencryptedOutputStream.write(keyCipher.iv)
            unencryptedOutputStream.write(passwordSalt)
            unencryptedOutputStream.write(encryptedStreamSecretKey) */

            // Sizes
            val contentCipherIvSizeBytes = intToTwoBytes(contentCipher.iv.size)
            println("contentCipher.iv.size (${contentCipher.iv.size}): ${contentCipherIvSizeBytes.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(contentCipherIvSizeBytes)

            val keyCipherIvSizeBytes = intToTwoBytes(keyCipher.iv.size)
            println("keyCipher.iv.size (${keyCipher.iv.size}): ${keyCipherIvSizeBytes.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(keyCipherIvSizeBytes)

            val passwordSaltSizeBytes = intToTwoBytes(passwordSalt.size)
            println("passwordSalt.size (${passwordSalt.size}): ${passwordSaltSizeBytes.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(passwordSaltSizeBytes)

            val encryptedStreamSecretKeySizeBytes = intToTwoBytes(encryptedStreamSecretKey.size)
            println("encryptedStreamSecretKey.size (${encryptedStreamSecretKey.size}): ${encryptedStreamSecretKeySizeBytes.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(encryptedStreamSecretKeySizeBytes)

            // Header contents
            println("contentCipher.iv: ${contentCipher.iv.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(contentCipher.iv)

            println("keyCipher.iv: ${keyCipher.iv.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(keyCipher.iv)

            println("passwordSalt: ${passwordSalt.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(passwordSalt)

            println("encryptedStreamSecretKey: ${encryptedStreamSecretKey.joinToString(", ") { it.toUByte().toString() }}")
            unencryptedOutputStream.write(encryptedStreamSecretKey)


            // Encrypt main content.
            CipherOutputStream(unencryptedOutputStream, contentCipher).use { encryptedOutputStream ->
                unencryptedInputStream.copyTo(encryptedOutputStream)
                encryptedOutputStream.flush()
            }
            true
        } catch (e: EmptyPasswordException) {
            Log.e("EmptyPasswordException", "Empty password supplied.", e)
            false
        } catch (e: Exception) {
            Log.e("EncryptionError", "Encryption failed (key: \"${keyAlias}\")", e)
            false
        }
    }

    fun decryptStream(
        encryptedInputStream: InputStream,
        iv: ByteArray,
        keyAlias: String,
        decryptedOutputStream: OutputStream
    ): Boolean {
        return try {
            val cipher = initCipher("DECRYPT", retrieveOrCreateKey(keyAlias), iv)

            CipherInputStream(encryptedInputStream, cipher).use { decryptedInputStream ->
                decryptedInputStream.copyTo(decryptedOutputStream)
            }
            true
        } catch(e: Exception) {
            Log.e("DecryptionError", "Decryption failed (key: \"${keyAlias}\")", e)
            false
        }
    }

    fun isIntegrityCheckPassed(encryptedFile: File, keyAlias: String): Boolean {
        return try {
            FileInputStream(encryptedFile).use { encryptedInputStream ->
                val encryptionHeader = extractDataFromHeader(encryptedInputStream)
                val cipher = initCipher(
                    "DECRYPT",
                    retrieveOrCreateKey(keyAlias),
                    encryptionHeader.contentCipherIv
                )

                CipherInputStream(encryptedInputStream, cipher).use { decryptedInputStream ->
                    // Reduces the number of IO calls, making it faster.
                    val buffer = ByteArray(4096)
                    while (decryptedInputStream.read(buffer) != -1) {
                        // Just read through the file to force decryption/authentication
                    }
                }
            }
            true
        } catch (e: Exception) {
            Log.e("IntegrityCheck", "ERROR: Unexpected failure during integrity verification")
            Log.e("IntegrityCheck", e.toString())
            false
        }
    }
}

class ErrorRetrievingKeyException(message: String, cause: Throwable? = null) : Exception(message, cause)
class EmptyPasswordException(message: String, cause: Throwable? = null) : Exception(message, cause)
